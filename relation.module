<?php

/**
 * Use the following suffix on field names.
 *
 * Usage:
 *
 * @code
 * // Create a relation field.
 * $relation_field = entity_create('field_entity', array('entity_type' => $entity_type, 'name' => RELATION_FIELD_NAME));
 *
 * // Load a relation field.
 * $relation_field = entity_load('field_entity', $entity_type . RELATION_FIELD_NAME);
 * @endcode
 */
const RELATION_FIELD_NAME = 'endpoints';

/**
 * @file
 * Describes relations between entities.
 */

use Drupal\Core\Language\Language;
use Drupal\Core\Cache\CacheBackendInterface;
use Drupal\Core\Field\FieldDefinitionInterface;
use Drupal\Core\Render\Element;
use Drupal\Core\Url;

/**
 * Implements hook_permission().
 */
function relation_permission() {
  return array(
    'administer relation types' => array(
      'title' => t('Administer Relation types'),
      'description' => t('Create, edit, delete, and perform administration tasks for relation types.'),
    ),
    'access relations' => array(
      'title' => t('View Relations'),
      'description' => t('View Relations of any Relation Type.'),
      'restrict access' => TRUE,
    ),
    'create relations' => array(
      'title' => t('Create Relations of any Relation Type'),
      'restrict access' => TRUE,
    ),
    'edit relations' => array(
      'title' => t('Edit Relations of any Relation Type'),
      'restrict access' => TRUE,
    ),
    'delete relations' => array(
      'title' => t('Delete Relations of any Relation Type'),
      'restrict access' => TRUE,
    ),
    'administer relations' => array(
      'title' => t('Administer all Relations'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_entity_bundle_info().
 */
function relation_entity_bundle_info() {
  $bundles = array();

  // Bundles must provide a human readable name so we can create help and error
  // messages.
  foreach (relation_type_get_names() as $id => $label) {
    $bundles['relation'][$id]['label'] = $label;
  }
  return $bundles;
}

/**
 * Implements hook_theme().
 */
function relation_theme() {
  $theme = array(
    'relation' => array(
      'render element' => 'elements',
      'template' => 'relation',
    ),
    'relation_admin_content' => array(
      'variables' => array('relations' => NULL)
    ),
  );
  return $theme;
}

/**
 * Prepares variables for relation templates.
 *
 * Default template: relation.html.twig.
 */
function template_preprocess_relation(&$variables) {
  $variables['relation'] = $variables['elements']['#relation'];

  $variables += array('content' => array());
  foreach (element_children($variables['elements']) as $key) {
    $variables['content'][$key] = $variables['elements'][$key];
  }
}

/**
 * Loads a relation type entity.
 *
 * @param $relation_id
 *   The machine name of the relation type (bundle) to be loaded.
 *
 * @return \Drupal\relation\Entity\RelationType
 */
function relation_type_load($relation_id) {
  return entity_load('relation_type', $relation_id);
}

/**
 * Returns all relation types suitable for #options property on elements.
 */
function relation_get_relation_types_options() {
  $options = array();
  foreach (entity_load_multiple('relation_type') as $relation_type) {
    $options[$relation_type->id()] = $relation_type->label();
  }
  return $options;
}

/**
 * Returns a list of available relation type names.
 *
 * This list can include types that are queued for addition or deletion.
 *
 * @return array
 *   An array of relation type labels, keyed by the relation type name.
 */
function relation_type_get_names() {
  $cid = 'relation_type:names:' . \Drupal::languageManager()->getCurrentLanguage()->id;
  if ($cache = \Drupal::cache()->get($cid)) {
    return $cache->data;
  }
  $config_names = \Drupal::configFactory()->listAll('relation.type.');

  $names = array();
  foreach ($config_names as $config_name) {
    $config = \Drupal::config($config_name);
    $names[$config->get('relation_type')] = $config->get('label');
  }
  \Drupal::cache()->set($cid, $names, CacheBackendInterface::CACHE_PERMANENT, array(
    'relation_type' => array_keys($names),
    'relation_types' => TRUE,
  ));
  return $names;
}

/**
 * Loads a relation from a relation id.
 *
 * @param $rid
 *   Numerical id of the relation to be loaded.
 *
 * @return
 *   Loaded relation object. Relation objects are stdClass Object of the form:
 *   - rid: numeric relation id.
 *   - relation_type: relation bundle machine name.
 *   - arity: the number of entities in the relation
 *   - rdf_mapping: not yet implemented (empty array)
 *   - endpoints: Field holding the entities that make up the relation.
 *     Field columns are:
 *     - entity_type: The type of the entity (eg. node).
 *     - entity_id: Numeric entity ID.
 */
function relation_load($rid) {
  return entity_load('relation', $rid);
}

/**
 * Checks if a relation exists.
 *
 * The following example demonstrates how to check if a relation of type
 * 'likes' exists between two entities, user 17 and node 253.
 *
 * @code
 *   $endpoints = array(
 *     array('entity_type' => 'user', 'entity_id' => 17),
 *     array('entity_type' => 'node', 'entity_id' => 253),
 *   );
 *   $relation_type = 'likes';
 *   $results = relation_relation_exists($endpoints, $relation_type);
 * @endcode
 *
 * @param array $endpoints
 *   An array containing endpoints. Each endpoint is an array with keys
 *   'entity_type' and 'entity_id'. The keys of each endpoint correspond to
 *   'r_index' if $enforce_direction is TRUE.
 * @param string $relation_type
 *   (Optional) The relation type (bundle) of the relation to be checked.
 * @param bool $enforce_direction
 *   (Optional) Whether to enforce direction as specified in $endpoints.
 *
 * @return array
 *   Array of Relation ID's keyed by revision ID.
 */
function relation_relation_exists($endpoints, $relation_type = NULL, $enforce_direction = FALSE) {
  $query = Drupal::entityQuery('relation');
  foreach ($endpoints as $r_index => $endpoint) {
    relation_query_add_related($query, $endpoint['entity_type'], $endpoint['entity_id'], $enforce_direction ? $r_index : NULL);
  }
  if ($relation_type) {
    $query->condition('relation_type', $relation_type);
  }
  $query->condition('arity', count($endpoints));

  // If direction of the relation is not forced make sure the each endpoint
  // is counted just once.
  if (!$enforce_direction) {
    $query->addTag('enforce_distinct_endpoints');
  }
  return $query->execute();
}

/**
 * Implements hook_query_TAG_alter().
 *
 * Adds conditions to query to ensure different r_index for each endpoint.
 */
function relation_query_enforce_distinct_endpoints_alter(Drupal\Core\Database\Query\AlterableInterface $query) {
  $arity = 0;
  $endpoints_table_name = &drupal_static(__FUNCTION__ . '.endpoints_table_name', NULL);

  if (!isset($endpoints_table_name)) {
    $field = \Drupal\field\Field::fieldInfo()->getField('relation', RELATION_FIELD_NAME);
    if ($field) {
      $endpoints_table_name = \Drupal::entityManager()->getStorage('relation')->_fieldTableName($field);
    }
    else {
      throw Exception('Could not get information about relation field.');
    }
  }

  // Get arity of the query
  $conditions = $query->conditions();
  foreach (Element::children($conditions) as $c) {
    $condition = $conditions[$c];
    if ($condition['field'] == 'relation.arity') {
      $arity = $condition['value'];
      break;
    }
  }
  // Add r_index conditions between all endpoints
  for ($i = 0; $i < $arity; $i++) {
    for ($k = $i + 1; $k < $arity; $k++) {
      // @see http://drupal.org/node/1859084, http://drupal.org/node/1760026
      // For now each endpoint condition adds 2 joins to the query. Add
      // conditions between even numbers.
      $left_suffix = !$i ? '' : '_' . ($i + 1);
      $right_suffix = !$k  ? '' : '_' . ($k + 1);
      $column_left = $endpoints_table_name . $left_suffix . '.endpoints_r_index';
      $column_right = $endpoints_table_name . $right_suffix . '.endpoints_r_index';
      $query->where("$column_left != $column_right");
    }
  }
}

/**
 * Clear the cache for a set of endpoints.
 *
 * @param $endpoints
 *   An array of endpoints, with entity_type and entity_id as keys.
 */
function relation_clear_related_entities_cache($endpoints) {
  drupal_static_reset('relation_get_related_entity');
  foreach ($endpoints as $endpoint) {
    \Drupal::cache()->delete('relation:' . $endpoint->entity_type . ':' . $endpoint->entity_id, 'cache', TRUE);
  }
}

/**
 * Constructs and saves a simple relation.
 *
 * @param $relation_type
 *   The relation type machine name.
 * @param $endpoints
 *   A list of endpoint entities. Each endpoint is defined by an associate
 *   array, with an entity_type and entity_id key. For example:
 *   @code
 *   array(
 *     array('entity_type' => 'node', 'entity_id' => 1),
 *     array('entity_type' => 'user', 'entity_id' => 5),
 *   );
 *   @endcode
 *
 * @return \Drupal\relation\Entity\Relation
 *   A saved relation.
 */
function relation_insert($relation_type, $endpoints) {
  $relation = entity_create('relation', array('relation_type' => $relation_type));
  $relation->endpoints = $endpoints;
  $relation->save();
  return $relation;
}

/**
 * Gets a relation's URI.
 *
 * @see entity_uri()
 */
function relation_uri(Drupal\relation\RelationInterface $relation) {
  return new Url('relation.view', array(
    'relation' => $relation->id(),
  ));
}

/**
 * Gets a relation type's URI.
 *
 * @see entity_uri()
 */
function relation_type_uri(Drupal\relation\RelationTypeInterface $relation_type) {
  return new Url('relation.type_edit', array(
    'relation' => $relation_type->id(),
  ));
}

/**
 * Returns a query object to find related entities.
 *
 * @param $entity_type
 *   (optional) The entity type of one of the endpoints.
 * @param $entity_id
 *   (optional) The entity id of one of the endpoints. Can also be an array of
 *   entity IDs.
 * @param $r_index
 *   (optional) The index of the search entity in the relation to be found
 *   (0 = source, 1 = target).
 *
 * @return RelationQuery
 *   The query object itself.
 *
 *   @todo deprecate this
 */
function relation_query($entity_type = NULL, $entity_id = NULL, $r_index = NULL) {
  $query = Drupal::entityQuery('relation');
  if ($entity_type) {
    relation_query_add_related($query, $entity_type, $entity_id, $r_index);
  }
  return $query;
}

/**
 * Add a related entity to the query.
 *
 * @param QueryInterface $query
 * @param $entity_type
 *   Entity type of the related entity.
 * @param $entity_id
 *   Entity id of the related entity. Can be an array of entity IDs.
 * @param $r_index
 *   The index of the related entity within the requested relation(s).
 *
 * @todo rename. / extend class ala RelationQuery::related()
 *
 * @return Drupal\Core\Entity\Query\QueryInterface
 */
function relation_query_add_related(Drupal\Core\Entity\Query\QueryInterface $query, $entity_type, $entity_id, $r_index = NULL) {
  $group = $query->andConditionGroup()
    ->condition('endpoints.entity_type', $entity_type, '=')
    ->condition('endpoints.entity_id', $entity_id, NULL);

  if (isset($r_index)) {
    $group->condition('endpoints.r_index', $r_index, '=');
  }

  $query->condition($group);
  return $query;
}

/**
 * Returns a related entity.
 *
 * Returns the entity object of the first other entity in the first relation
 * that matches the given conditions. Do not expect to get exactly what you
 * want, especially if you have multiple relations of the same type on the
 * search entity.
 *
 * @param $entity_type
 *   The entity type of one of the endpoints.
 * @param $entity_id
 *   The entity id of one of the endpoints.
 * @param $relation_type
 *   (optional) The relation type of the relation to find.
 * @param $r_index
 *   (optional) The index of the search entity in the relation to be found
 *   (0 = source, 1 = target).
 *
 * @return
 *   The entity object from the other endpoint.
 */
function relation_get_related_entity($entity_type, $entity_id, $relation_type = NULL, $r_index = NULL) {

  // Static cache the results of relation_query() and relation_load() to avoid
  // duplicate queries if this is called multiple times with the same arguments
  // during a request.
  $items = &drupal_static(__FUNCTION__);
  $request_key = "$entity_type:$entity_id";
  $cache_key = "$request_key:$relation_type:$r_index";

  if (isset($items[$cache_key])) {
    $entities = $items[$cache_key];
  }
  elseif ($cached = \Drupal::cache()->get("relation:$cache_key")) {
    $entities = $cached->data;
    $items[$cache_key] = $entities;
  }
  else {
    $query = Drupal::entityQuery('relation');
    relation_query_add_related($query, $entity_type, $entity_id, $r_index)
      ->range(0, 1);
    if ($relation_type) {
      $query->condition('relation_type', $relation_type);
    }
    $results = $query->execute();
    $relation_id = reset($results);

    if ($relation_id) {
      $relation = entity_load('relation', $relation_id);
      if ($relation->arity->value == 1) {
        $entities = FALSE;
      }
      else {
        $entities = $relation->endpoints;
      }
    }
    else {
      $entities = FALSE;
    }
    \Drupal::cache()->set("relation:$cache_key", $entities);

    $items[$cache_key] = $entities;
  }
  if ($entities) {
    $first_entity_key = $entities[0]->entity_type . ':' . $entities[0]->entity_id;
    if (isset($r_index)) {
      $request_key = $request_key . ':' . $r_index;
      $first_entity_key = $first_entity_key . ':' . $entities[0]->r_index;
    }
    if ($request_key == $first_entity_key) {
      return entity_load($entities[1]->entity_type, $entities[1]->entity_id);
    }
    return entity_load($entities[0]->entity_type, $entities[0]->entity_id);
  }

  return FALSE;
}

/**
 * Returns the relation types that can have the given entity as an endpoint.
 *
 * @param $entity_type
 *   The entity type of the endpoint.
 * @param $bundle
 *   The bundle of the endpoint.
 * @param $endpoint
 *   (optional) the type of endpoint. This is only used for directional
 *   relation types. Possible options are 'source', 'target', or 'both'.
 *
 * @return array
 *   An array of relation types
 */
function relation_get_available_relation_types($entity_type, $bundle, $endpoint = 'source') {
  $bundle_key = $entity_type . ':' . $bundle;
  $all_bundle_key = $entity_type . ':*';
  $available_types = array();

  foreach (entity_load_multiple('relation_type') as $relation_type) {
    $available = FALSE;
    if ($endpoint == 'source' || $endpoint == 'both') {
      if (in_array($bundle_key, $relation_type->source_bundles) || in_array($all_bundle_key, $relation_type->source_bundles)) {
        $available = TRUE;
      }
    }
    if ($endpoint == 'target' || $endpoint == 'both') {
      if (in_array($bundle_key, $relation_type->target_bundles) || in_array($all_bundle_key, $relation_type->target_bundles)) {
        $available = TRUE;
      }
    }
    if ($available) {
      $available_types[] = $relation_type;
    }
  }

  return $available_types;
}

/**
 * Implements hook_entity_delete().
 */
function relation_entity_delete(Drupal\Core\Entity\EntityInterface $entity) {
  if ($entity->getEntityTypeId() == 'relation' && $entity->endpoints) {
    relation_clear_related_entities_cache($entity->endpoints);
  }

  // Delete relations to this entity.
  $relation_ids = relation_query($entity->getEntityTypeId(), $entity->id())->execute();
  $relations_to_delete = array(); // ids of relations to delete
  foreach (entity_load_multiple('relation', $relation_ids) as $relation) {
    // Remove any endpoints pointing to entity`
    foreach ($relation->endpoints as $key => $endpoint) {
      if ($endpoint->entity_id == $entity->id() && $endpoint->entity_type == $entity->getEntityTypeId()) {
        unset($relation->endpoints[$key]);
      }
    }

    // Check if relation remains valid with regards to arity
    $relation_type = entity_load('relation_type', $relation->bundle());
    $arity = count($relation->endpoints);
    if ($relation_type && ($arity < $relation_type->min_arity)) {
      // Not valid - delete
      array_push($relations_to_delete, $relation->id());
    }
    else {
      // Valid - save
      $relation->save();
    }
  }
  if (!empty($relations_to_delete)) {
    entity_delete_multiple('relation', $relations_to_delete);
    watchdog('relation', t('Relations @relations have been deleted.', array('@relations' => implode(', ', $relations_to_delete))));
  }
}

/**
 * Implements hook_views_api().
 */
function relation_views_api() {
  return array(
    'api' => 3.0,
    'path' => drupal_get_path('module', 'relation') . '/views',
  );
}

/**
 * Adds a endpoint field to a bundle.
 *
 * @param $entity_type
 *   An entity type. Usually 'relation_type'.
 *
 * @return \Drupal\Core\Entity\EntityInterface
 */
function relation_add_endpoint_field($bundle) {
  $field = \Drupal\field\Field::fieldInfo()->getField('relation', RELATION_FIELD_NAME);
  $instance = \Drupal\field\Field::fieldInfo()->getInstance('relation', $bundle, RELATION_FIELD_NAME);

  if (empty($field)) {
    $field = entity_create('field_config', array(
      'entity_type' => 'relation',
      'name' => RELATION_FIELD_NAME,
      'cardinality' => FieldDefinitionInterface::CARDINALITY_UNLIMITED,
      'type' => 'relation_endpoint',
    ));
    $field->save();
  }

  if (empty($instance)) {
    $instance = entity_create('field_instance_config', array(
      'field_name' => RELATION_FIELD_NAME,
      'entity_type' => 'relation',
      'bundle' => $bundle,
      'label' => t('Endpoints'),
      'settings' => array(),
    ));
    $instance->save();

    entity_get_form_display('relation', $bundle, 'default')
      ->setComponent(RELATION_FIELD_NAME, array(
        'type' => 'relation_endpoint',
      ))
      ->save();

    entity_get_display('relation' , $bundle, 'default')
      ->setComponent(RELATION_FIELD_NAME, array(
        'label' => 'hidden',
        'type' => 'relation_endpoint',
      ))
      ->save();
  }
}
